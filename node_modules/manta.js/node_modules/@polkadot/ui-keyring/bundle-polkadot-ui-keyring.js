const polkadotUiKeyring = (function (exports, keyring$1, uiSettings, util$7, utilCrypto, hwLedger) {
  'use strict';

  const global = window;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }

    return receiver;
  }

  var id = 0;
  function _classPrivateFieldKey(name) {
    return "__private_" + id++ + "_" + name;
  }

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }

  function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  }

  function __spreadArray(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
          to[j] = from[i];
      return to;
  }

  function __await(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
  }

  function __asyncGenerator(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
      function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
      function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
      function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
      function fulfill(value) { resume("next", value); }
      function reject(value) { resume("throw", value); }
      function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
  }

  function __asyncValues(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
      function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
      function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
  }

  function isFunction$2(value) {
      return typeof value === 'function';
  }

  function createErrorClass(createImpl) {
      var _super = function (instance) {
          Error.call(instance);
          instance.stack = new Error().stack;
      };
      var ctorFunc = createImpl(_super);
      ctorFunc.prototype = Object.create(Error.prototype);
      ctorFunc.prototype.constructor = ctorFunc;
      return ctorFunc;
  }

  var UnsubscriptionError = createErrorClass(function (_super) {
      return function UnsubscriptionErrorImpl(errors) {
          _super(this);
          this.message = errors
              ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
              : '';
          this.name = 'UnsubscriptionError';
          this.errors = errors;
      };
  });

  function arrRemove(arr, item) {
      if (arr) {
          var index = arr.indexOf(item);
          0 <= index && arr.splice(index, 1);
      }
  }

  var Subscription = (function () {
      function Subscription(initialTeardown) {
          this.initialTeardown = initialTeardown;
          this.closed = false;
          this._parentage = null;
          this._teardowns = null;
      }
      Subscription.prototype.unsubscribe = function () {
          var e_1, _a, e_2, _b;
          var errors;
          if (!this.closed) {
              this.closed = true;
              var _parentage = this._parentage;
              if (_parentage) {
                  this._parentage = null;
                  if (Array.isArray(_parentage)) {
                      try {
                          for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                              var parent_1 = _parentage_1_1.value;
                              parent_1.remove(this);
                          }
                      }
                      catch (e_1_1) { e_1 = { error: e_1_1 }; }
                      finally {
                          try {
                              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                          }
                          finally { if (e_1) throw e_1.error; }
                      }
                  }
                  else {
                      _parentage.remove(this);
                  }
              }
              var initialTeardown = this.initialTeardown;
              if (isFunction$2(initialTeardown)) {
                  try {
                      initialTeardown();
                  }
                  catch (e) {
                      errors = e instanceof UnsubscriptionError ? e.errors : [e];
                  }
              }
              var _teardowns = this._teardowns;
              if (_teardowns) {
                  this._teardowns = null;
                  try {
                      for (var _teardowns_1 = __values(_teardowns), _teardowns_1_1 = _teardowns_1.next(); !_teardowns_1_1.done; _teardowns_1_1 = _teardowns_1.next()) {
                          var teardown_1 = _teardowns_1_1.value;
                          try {
                              execTeardown(teardown_1);
                          }
                          catch (err) {
                              errors = errors !== null && errors !== void 0 ? errors : [];
                              if (err instanceof UnsubscriptionError) {
                                  errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                              }
                              else {
                                  errors.push(err);
                              }
                          }
                      }
                  }
                  catch (e_2_1) { e_2 = { error: e_2_1 }; }
                  finally {
                      try {
                          if (_teardowns_1_1 && !_teardowns_1_1.done && (_b = _teardowns_1.return)) _b.call(_teardowns_1);
                      }
                      finally { if (e_2) throw e_2.error; }
                  }
              }
              if (errors) {
                  throw new UnsubscriptionError(errors);
              }
          }
      };
      Subscription.prototype.add = function (teardown) {
          var _a;
          if (teardown && teardown !== this) {
              if (this.closed) {
                  execTeardown(teardown);
              }
              else {
                  if (teardown instanceof Subscription) {
                      if (teardown.closed || teardown._hasParent(this)) {
                          return;
                      }
                      teardown._addParent(this);
                  }
                  (this._teardowns = (_a = this._teardowns) !== null && _a !== void 0 ? _a : []).push(teardown);
              }
          }
      };
      Subscription.prototype._hasParent = function (parent) {
          var _parentage = this._parentage;
          return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
      };
      Subscription.prototype._addParent = function (parent) {
          var _parentage = this._parentage;
          this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      };
      Subscription.prototype._removeParent = function (parent) {
          var _parentage = this._parentage;
          if (_parentage === parent) {
              this._parentage = null;
          }
          else if (Array.isArray(_parentage)) {
              arrRemove(_parentage, parent);
          }
      };
      Subscription.prototype.remove = function (teardown) {
          var _teardowns = this._teardowns;
          _teardowns && arrRemove(_teardowns, teardown);
          if (teardown instanceof Subscription) {
              teardown._removeParent(this);
          }
      };
      Subscription.EMPTY = (function () {
          var empty = new Subscription();
          empty.closed = true;
          return empty;
      })();
      return Subscription;
  }());
  var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
      return (value instanceof Subscription ||
          (value && 'closed' in value && isFunction$2(value.remove) && isFunction$2(value.add) && isFunction$2(value.unsubscribe)));
  }
  function execTeardown(teardown) {
      if (isFunction$2(teardown)) {
          teardown();
      }
      else {
          teardown.unsubscribe();
      }
  }

  var config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: undefined,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false,
  };

  var timeoutProvider = {
      setTimeout: function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          var delegate = timeoutProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) || setTimeout).apply(void 0, __spreadArray([], __read(args)));
      },
      clearTimeout: function (handle) {
          var delegate = timeoutProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: undefined,
  };

  function reportUnhandledError(err) {
      timeoutProvider.setTimeout(function () {
          {
              throw err;
          }
      });
  }

  function noop() { }

  var context = null;
  function errorContext(cb) {
      if (config.useDeprecatedSynchronousErrorHandling) {
          var isRoot = !context;
          if (isRoot) {
              context = { errorThrown: false, error: null };
          }
          cb();
          if (isRoot) {
              var _a = context, errorThrown = _a.errorThrown, error = _a.error;
              context = null;
              if (errorThrown) {
                  throw error;
              }
          }
      }
      else {
          cb();
      }
  }

  var Subscriber = (function (_super) {
      __extends(Subscriber, _super);
      function Subscriber(destination) {
          var _this = _super.call(this) || this;
          _this.isStopped = false;
          if (destination) {
              _this.destination = destination;
              if (isSubscription(destination)) {
                  destination.add(_this);
              }
          }
          else {
              _this.destination = EMPTY_OBSERVER;
          }
          return _this;
      }
      Subscriber.create = function (next, error, complete) {
          return new SafeSubscriber(next, error, complete);
      };
      Subscriber.prototype.next = function (value) {
          if (this.isStopped) ;
          else {
              this._next(value);
          }
      };
      Subscriber.prototype.error = function (err) {
          if (this.isStopped) ;
          else {
              this.isStopped = true;
              this._error(err);
          }
      };
      Subscriber.prototype.complete = function () {
          if (this.isStopped) ;
          else {
              this.isStopped = true;
              this._complete();
          }
      };
      Subscriber.prototype.unsubscribe = function () {
          if (!this.closed) {
              this.isStopped = true;
              _super.prototype.unsubscribe.call(this);
              this.destination = null;
          }
      };
      Subscriber.prototype._next = function (value) {
          this.destination.next(value);
      };
      Subscriber.prototype._error = function (err) {
          try {
              this.destination.error(err);
          }
          finally {
              this.unsubscribe();
          }
      };
      Subscriber.prototype._complete = function () {
          try {
              this.destination.complete();
          }
          finally {
              this.unsubscribe();
          }
      };
      return Subscriber;
  }(Subscription));
  var SafeSubscriber = (function (_super) {
      __extends(SafeSubscriber, _super);
      function SafeSubscriber(observerOrNext, error, complete) {
          var _this = _super.call(this) || this;
          var next;
          if (isFunction$2(observerOrNext)) {
              next = observerOrNext;
          }
          else if (observerOrNext) {
              (next = observerOrNext.next, error = observerOrNext.error, complete = observerOrNext.complete);
              var context_1;
              if (_this && config.useDeprecatedNextContext) {
                  context_1 = Object.create(observerOrNext);
                  context_1.unsubscribe = function () { return _this.unsubscribe(); };
              }
              else {
                  context_1 = observerOrNext;
              }
              next = next === null || next === void 0 ? void 0 : next.bind(context_1);
              error = error === null || error === void 0 ? void 0 : error.bind(context_1);
              complete = complete === null || complete === void 0 ? void 0 : complete.bind(context_1);
          }
          _this.destination = {
              next: next ? wrapForErrorHandling(next) : noop,
              error: wrapForErrorHandling(error !== null && error !== void 0 ? error : defaultErrorHandler),
              complete: complete ? wrapForErrorHandling(complete) : noop,
          };
          return _this;
      }
      return SafeSubscriber;
  }(Subscriber));
  function wrapForErrorHandling(handler, instance) {
      return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          try {
              handler.apply(void 0, __spreadArray([], __read(args)));
          }
          catch (err) {
              {
                  reportUnhandledError(err);
              }
          }
      };
  }
  function defaultErrorHandler(err) {
      throw err;
  }
  var EMPTY_OBSERVER = {
      closed: true,
      next: noop,
      error: defaultErrorHandler,
      complete: noop,
  };

  var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();

  function identity(x) {
      return x;
  }

  function pipeFromArray(fns) {
      if (fns.length === 0) {
          return identity;
      }
      if (fns.length === 1) {
          return fns[0];
      }
      return function piped(input) {
          return fns.reduce(function (prev, fn) { return fn(prev); }, input);
      };
  }

  var Observable = (function () {
      function Observable(subscribe) {
          if (subscribe) {
              this._subscribe = subscribe;
          }
      }
      Observable.prototype.lift = function (operator) {
          var observable = new Observable();
          observable.source = this;
          observable.operator = operator;
          return observable;
      };
      Observable.prototype.subscribe = function (observerOrNext, error, complete) {
          var _this = this;
          var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
          errorContext(function () {
              var _a = _this, operator = _a.operator, source = _a.source;
              subscriber.add(operator
                  ?
                      operator.call(subscriber, source)
                  : source
                      ?
                          _this._subscribe(subscriber)
                      :
                          _this._trySubscribe(subscriber));
          });
          return subscriber;
      };
      Observable.prototype._trySubscribe = function (sink) {
          try {
              return this._subscribe(sink);
          }
          catch (err) {
              sink.error(err);
          }
      };
      Observable.prototype.forEach = function (next, promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function (resolve, reject) {
              var subscription;
              subscription = _this.subscribe(function (value) {
                  try {
                      next(value);
                  }
                  catch (err) {
                      reject(err);
                      subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
                  }
              }, reject, resolve);
          });
      };
      Observable.prototype._subscribe = function (subscriber) {
          var _a;
          return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
      };
      Observable.prototype[observable] = function () {
          return this;
      };
      Observable.prototype.pipe = function () {
          var operations = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              operations[_i] = arguments[_i];
          }
          return pipeFromArray(operations)(this);
      };
      Observable.prototype.toPromise = function (promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function (resolve, reject) {
              var value;
              _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
          });
      };
      Observable.create = function (subscribe) {
          return new Observable(subscribe);
      };
      return Observable;
  }());
  function getPromiseCtor(promiseCtor) {
      var _a;
      return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
      return value && isFunction$2(value.next) && isFunction$2(value.error) && isFunction$2(value.complete);
  }
  function isSubscriber(value) {
      return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));
  }

  function hasLift(source) {
      return isFunction$2(source === null || source === void 0 ? void 0 : source.lift);
  }
  function operate(init) {
      return function (source) {
          if (hasLift(source)) {
              return source.lift(function (liftedSource) {
                  try {
                      return init(liftedSource, this);
                  }
                  catch (err) {
                      this.error(err);
                  }
              });
          }
          throw new TypeError('Unable to lift unknown Observable type');
      };
  }

  var OperatorSubscriber = (function (_super) {
      __extends(OperatorSubscriber, _super);
      function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
          var _this = _super.call(this, destination) || this;
          _this.onFinalize = onFinalize;
          _this._next = onNext
              ? function (value) {
                  try {
                      onNext(value);
                  }
                  catch (err) {
                      destination.error(err);
                  }
              }
              : _super.prototype._next;
          _this._error = onError
              ? function (err) {
                  try {
                      onError(err);
                  }
                  catch (err) {
                      destination.error(err);
                  }
                  finally {
                      this.unsubscribe();
                  }
              }
              : _super.prototype._error;
          _this._complete = onComplete
              ? function () {
                  try {
                      onComplete();
                  }
                  catch (err) {
                      destination.error(err);
                  }
                  finally {
                      this.unsubscribe();
                  }
              }
              : _super.prototype._complete;
          return _this;
      }
      OperatorSubscriber.prototype.unsubscribe = function () {
          var _a;
          var closed = this.closed;
          _super.prototype.unsubscribe.call(this);
          !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
      };
      return OperatorSubscriber;
  }(Subscriber));

  var ObjectUnsubscribedError = createErrorClass(function (_super) {
      return function ObjectUnsubscribedErrorImpl() {
          _super(this);
          this.name = 'ObjectUnsubscribedError';
          this.message = 'object unsubscribed';
      };
  });

  var Subject = (function (_super) {
      __extends(Subject, _super);
      function Subject() {
          var _this = _super.call(this) || this;
          _this.closed = false;
          _this.observers = [];
          _this.isStopped = false;
          _this.hasError = false;
          _this.thrownError = null;
          return _this;
      }
      Subject.prototype.lift = function (operator) {
          var subject = new AnonymousSubject(this, this);
          subject.operator = operator;
          return subject;
      };
      Subject.prototype._throwIfClosed = function () {
          if (this.closed) {
              throw new ObjectUnsubscribedError();
          }
      };
      Subject.prototype.next = function (value) {
          var _this = this;
          errorContext(function () {
              var e_1, _a;
              _this._throwIfClosed();
              if (!_this.isStopped) {
                  var copy = _this.observers.slice();
                  try {
                      for (var copy_1 = __values(copy), copy_1_1 = copy_1.next(); !copy_1_1.done; copy_1_1 = copy_1.next()) {
                          var observer = copy_1_1.value;
                          observer.next(value);
                      }
                  }
                  catch (e_1_1) { e_1 = { error: e_1_1 }; }
                  finally {
                      try {
                          if (copy_1_1 && !copy_1_1.done && (_a = copy_1.return)) _a.call(copy_1);
                      }
                      finally { if (e_1) throw e_1.error; }
                  }
              }
          });
      };
      Subject.prototype.error = function (err) {
          var _this = this;
          errorContext(function () {
              _this._throwIfClosed();
              if (!_this.isStopped) {
                  _this.hasError = _this.isStopped = true;
                  _this.thrownError = err;
                  var observers = _this.observers;
                  while (observers.length) {
                      observers.shift().error(err);
                  }
              }
          });
      };
      Subject.prototype.complete = function () {
          var _this = this;
          errorContext(function () {
              _this._throwIfClosed();
              if (!_this.isStopped) {
                  _this.isStopped = true;
                  var observers = _this.observers;
                  while (observers.length) {
                      observers.shift().complete();
                  }
              }
          });
      };
      Subject.prototype.unsubscribe = function () {
          this.isStopped = this.closed = true;
          this.observers = null;
      };
      Object.defineProperty(Subject.prototype, "observed", {
          get: function () {
              var _a;
              return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
          },
          enumerable: false,
          configurable: true
      });
      Subject.prototype._trySubscribe = function (subscriber) {
          this._throwIfClosed();
          return _super.prototype._trySubscribe.call(this, subscriber);
      };
      Subject.prototype._subscribe = function (subscriber) {
          this._throwIfClosed();
          this._checkFinalizedStatuses(subscriber);
          return this._innerSubscribe(subscriber);
      };
      Subject.prototype._innerSubscribe = function (subscriber) {
          var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
          return hasError || isStopped
              ? EMPTY_SUBSCRIPTION
              : (observers.push(subscriber), new Subscription(function () { return arrRemove(observers, subscriber); }));
      };
      Subject.prototype._checkFinalizedStatuses = function (subscriber) {
          var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
          if (hasError) {
              subscriber.error(thrownError);
          }
          else if (isStopped) {
              subscriber.complete();
          }
      };
      Subject.prototype.asObservable = function () {
          var observable = new Observable();
          observable.source = this;
          return observable;
      };
      Subject.create = function (destination, source) {
          return new AnonymousSubject(destination, source);
      };
      return Subject;
  }(Observable));
  var AnonymousSubject = (function (_super) {
      __extends(AnonymousSubject, _super);
      function AnonymousSubject(destination, source) {
          var _this = _super.call(this) || this;
          _this.destination = destination;
          _this.source = source;
          return _this;
      }
      AnonymousSubject.prototype.next = function (value) {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
      };
      AnonymousSubject.prototype.error = function (err) {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
      };
      AnonymousSubject.prototype.complete = function () {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
      };
      AnonymousSubject.prototype._subscribe = function (subscriber) {
          var _a, _b;
          return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
      };
      return AnonymousSubject;
  }(Subject));

  var BehaviorSubject = (function (_super) {
      __extends(BehaviorSubject, _super);
      function BehaviorSubject(_value) {
          var _this = _super.call(this) || this;
          _this._value = _value;
          return _this;
      }
      Object.defineProperty(BehaviorSubject.prototype, "value", {
          get: function () {
              return this.getValue();
          },
          enumerable: false,
          configurable: true
      });
      BehaviorSubject.prototype._subscribe = function (subscriber) {
          var subscription = _super.prototype._subscribe.call(this, subscriber);
          !subscription.closed && subscriber.next(this._value);
          return subscription;
      };
      BehaviorSubject.prototype.getValue = function () {
          var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
          if (hasError) {
              throw thrownError;
          }
          this._throwIfClosed();
          return _value;
      };
      BehaviorSubject.prototype.next = function (value) {
          _super.prototype.next.call(this, (this._value = value));
      };
      return BehaviorSubject;
  }(Subject));

  function scheduleArray(input, scheduler) {
      return new Observable(function (subscriber) {
          var i = 0;
          return scheduler.schedule(function () {
              if (i === input.length) {
                  subscriber.complete();
              }
              else {
                  subscriber.next(input[i++]);
                  if (!subscriber.closed) {
                      this.schedule();
                  }
              }
          });
      });
  }

  var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

  function isPromise(value) {
      return isFunction$2(value === null || value === void 0 ? void 0 : value.then);
  }

  function scheduleObservable(input, scheduler) {
      return new Observable(function (subscriber) {
          var sub = new Subscription();
          sub.add(scheduler.schedule(function () {
              var observable$1 = input[observable]();
              sub.add(observable$1.subscribe({
                  next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                  error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                  complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
              }));
          }));
          return sub;
      });
  }

  function schedulePromise(input, scheduler) {
      return new Observable(function (subscriber) {
          return scheduler.schedule(function () {
              return input.then(function (value) {
                  subscriber.add(scheduler.schedule(function () {
                      subscriber.next(value);
                      subscriber.add(scheduler.schedule(function () { return subscriber.complete(); }));
                  }));
              }, function (err) {
                  subscriber.add(scheduler.schedule(function () { return subscriber.error(err); }));
              });
          });
      });
  }

  function getSymbolIterator() {
      if (typeof Symbol !== 'function' || !Symbol.iterator) {
          return '@@iterator';
      }
      return Symbol.iterator;
  }
  var iterator = getSymbolIterator();

  function caughtSchedule(subscriber, scheduler, execute, delay) {
      if (delay === void 0) { delay = 0; }
      var subscription = scheduler.schedule(function () {
          try {
              execute.call(this);
          }
          catch (err) {
              subscriber.error(err);
          }
      }, delay);
      subscriber.add(subscription);
      return subscription;
  }

  function scheduleIterable(input, scheduler) {
      return new Observable(function (subscriber) {
          var iterator$1;
          subscriber.add(scheduler.schedule(function () {
              iterator$1 = input[iterator]();
              caughtSchedule(subscriber, scheduler, function () {
                  var _a = iterator$1.next(), value = _a.value, done = _a.done;
                  if (done) {
                      subscriber.complete();
                  }
                  else {
                      subscriber.next(value);
                      this.schedule();
                  }
              });
          }));
          return function () { return isFunction$2(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return(); };
      });
  }

  function scheduleAsyncIterable(input, scheduler) {
      if (!input) {
          throw new Error('Iterable cannot be null');
      }
      return new Observable(function (subscriber) {
          var sub = new Subscription();
          sub.add(scheduler.schedule(function () {
              var iterator = input[Symbol.asyncIterator]();
              sub.add(scheduler.schedule(function () {
                  var _this = this;
                  iterator.next().then(function (result) {
                      if (result.done) {
                          subscriber.complete();
                      }
                      else {
                          subscriber.next(result.value);
                          _this.schedule();
                      }
                  });
              }));
          }));
          return sub;
      });
  }

  function isInteropObservable(input) {
      return isFunction$2(input[observable]);
  }

  function isIterable(input) {
      return isFunction$2(input === null || input === void 0 ? void 0 : input[iterator]);
  }

  function isAsyncIterable(obj) {
      return Symbol.asyncIterator && isFunction$2(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }

  function createInvalidObservableTypeError(input) {
      return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }

  function readableStreamLikeToAsyncGenerator(readableStream) {
      return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
          var reader, _a, value, done;
          return __generator(this, function (_b) {
              switch (_b.label) {
                  case 0:
                      reader = readableStream.getReader();
                      _b.label = 1;
                  case 1:
                      _b.trys.push([1, , 9, 10]);
                      _b.label = 2;
                  case 2:
                      return [4, __await(reader.read())];
                  case 3:
                      _a = _b.sent(), value = _a.value, done = _a.done;
                      if (!done) return [3, 5];
                      return [4, __await(void 0)];
                  case 4: return [2, _b.sent()];
                  case 5: return [4, __await(value)];
                  case 6: return [4, _b.sent()];
                  case 7:
                      _b.sent();
                      return [3, 2];
                  case 8: return [3, 10];
                  case 9:
                      reader.releaseLock();
                      return [7];
                  case 10: return [2];
              }
          });
      });
  }
  function isReadableStreamLike(obj) {
      return isFunction$2(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }

  function scheduleReadableStreamLike(input, scheduler) {
      return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
  }

  function scheduled(input, scheduler) {
      if (input != null) {
          if (isInteropObservable(input)) {
              return scheduleObservable(input, scheduler);
          }
          if (isArrayLike(input)) {
              return scheduleArray(input, scheduler);
          }
          if (isPromise(input)) {
              return schedulePromise(input, scheduler);
          }
          if (isAsyncIterable(input)) {
              return scheduleAsyncIterable(input, scheduler);
          }
          if (isIterable(input)) {
              return scheduleIterable(input, scheduler);
          }
          if (isReadableStreamLike(input)) {
              return scheduleReadableStreamLike(input, scheduler);
          }
      }
      throw createInvalidObservableTypeError(input);
  }

  function from(input, scheduler) {
      return scheduler ? scheduled(input, scheduler) : innerFrom(input);
  }
  function innerFrom(input) {
      if (input instanceof Observable) {
          return input;
      }
      if (input != null) {
          if (isInteropObservable(input)) {
              return fromInteropObservable(input);
          }
          if (isArrayLike(input)) {
              return fromArrayLike(input);
          }
          if (isPromise(input)) {
              return fromPromise(input);
          }
          if (isAsyncIterable(input)) {
              return fromAsyncIterable(input);
          }
          if (isIterable(input)) {
              return fromIterable(input);
          }
          if (isReadableStreamLike(input)) {
              return fromReadableStreamLike(input);
          }
      }
      throw createInvalidObservableTypeError(input);
  }
  function fromInteropObservable(obj) {
      return new Observable(function (subscriber) {
          var obs = obj[observable]();
          if (isFunction$2(obs.subscribe)) {
              return obs.subscribe(subscriber);
          }
          throw new TypeError('Provided object does not correctly implement Symbol.observable');
      });
  }
  function fromArrayLike(array) {
      return new Observable(function (subscriber) {
          for (var i = 0; i < array.length && !subscriber.closed; i++) {
              subscriber.next(array[i]);
          }
          subscriber.complete();
      });
  }
  function fromPromise(promise) {
      return new Observable(function (subscriber) {
          promise
              .then(function (value) {
              if (!subscriber.closed) {
                  subscriber.next(value);
                  subscriber.complete();
              }
          }, function (err) { return subscriber.error(err); })
              .then(null, reportUnhandledError);
      });
  }
  function fromIterable(iterable) {
      return new Observable(function (subscriber) {
          var e_1, _a;
          try {
              for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                  var value = iterable_1_1.value;
                  subscriber.next(value);
                  if (subscriber.closed) {
                      return;
                  }
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
          subscriber.complete();
      });
  }
  function fromAsyncIterable(asyncIterable) {
      return new Observable(function (subscriber) {
          process(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });
      });
  }
  function fromReadableStreamLike(readableStream) {
      return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
  }
  function process(asyncIterable, subscriber) {
      var asyncIterable_1, asyncIterable_1_1;
      var e_2, _a;
      return __awaiter(this, void 0, void 0, function () {
          var value, e_2_1;
          return __generator(this, function (_b) {
              switch (_b.label) {
                  case 0:
                      _b.trys.push([0, 5, 6, 11]);
                      asyncIterable_1 = __asyncValues(asyncIterable);
                      _b.label = 1;
                  case 1: return [4, asyncIterable_1.next()];
                  case 2:
                      if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
                      value = asyncIterable_1_1.value;
                      subscriber.next(value);
                      if (subscriber.closed) {
                          return [2];
                      }
                      _b.label = 3;
                  case 3: return [3, 1];
                  case 4: return [3, 11];
                  case 5:
                      e_2_1 = _b.sent();
                      e_2 = { error: e_2_1 };
                      return [3, 11];
                  case 6:
                      _b.trys.push([6, , 9, 10]);
                      if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
                      return [4, _a.call(asyncIterable_1)];
                  case 7:
                      _b.sent();
                      _b.label = 8;
                  case 8: return [3, 10];
                  case 9:
                      if (e_2) throw e_2.error;
                      return [7];
                  case 10: return [7];
                  case 11:
                      subscriber.complete();
                      return [2];
              }
          });
      });
  }

  function isScheduler(value) {
      return value && isFunction$2(value.schedule);
  }

  function last(arr) {
      return arr[arr.length - 1];
  }
  function popResultSelector(args) {
      return isFunction$2(last(args)) ? args.pop() : undefined;
  }
  function popScheduler(args) {
      return isScheduler(last(args)) ? args.pop() : undefined;
  }

  function map$1(project, thisArg) {
      return operate(function (source, subscriber) {
          var index = 0;
          source.subscribe(new OperatorSubscriber(subscriber, function (value) {
              subscriber.next(project.call(thisArg, value, index++));
          }));
      });
  }

  var isArray$1 = Array.isArray;
  function callOrApply(fn, args) {
      return isArray$1(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
  }
  function mapOneOrManyArgs(fn) {
      return map$1(function (args) { return callOrApply(fn, args); });
  }

  var isArray = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
  function argsArgArrayOrObject(args) {
      if (args.length === 1) {
          var first_1 = args[0];
          if (isArray(first_1)) {
              return { args: first_1, keys: null };
          }
          if (isPOJO(first_1)) {
              var keys = getKeys(first_1);
              return {
                  args: keys.map(function (key) { return first_1[key]; }),
                  keys: keys,
              };
          }
      }
      return { args: args, keys: null };
  }
  function isPOJO(obj) {
      return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;
  }

  function createObject(keys, values) {
      return keys.reduce(function (result, key, i) { return ((result[key] = values[i]), result); }, {});
  }

  function combineLatest() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
      }
      var scheduler = popScheduler(args);
      var resultSelector = popResultSelector(args);
      var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
      if (observables.length === 0) {
          return from([], scheduler);
      }
      var result = new Observable(combineLatestInit(observables, scheduler, keys
          ?
              function (values) { return createObject(keys, values); }
          :
              identity));
      return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
  }
  function combineLatestInit(observables, scheduler, valueTransform) {
      if (valueTransform === void 0) { valueTransform = identity; }
      return function (subscriber) {
          maybeSchedule(scheduler, function () {
              var length = observables.length;
              var values = new Array(length);
              var active = length;
              var remainingFirstValues = length;
              var _loop_1 = function (i) {
                  maybeSchedule(scheduler, function () {
                      var source = from(observables[i], scheduler);
                      var hasFirstValue = false;
                      source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                          values[i] = value;
                          if (!hasFirstValue) {
                              hasFirstValue = true;
                              remainingFirstValues--;
                          }
                          if (!remainingFirstValues) {
                              subscriber.next(valueTransform(values.slice()));
                          }
                      }, function () {
                          if (!--active) {
                              subscriber.complete();
                          }
                      }));
                  }, subscriber);
              };
              for (var i = 0; i < length; i++) {
                  _loop_1(i);
              }
          }, subscriber);
      };
  }
  function maybeSchedule(scheduler, execute, subscription) {
      if (scheduler) {
          subscription.add(scheduler.schedule(execute));
      }
      else {
          execute();
      }
  }

  // Copyright 2017-2021 @polkadot/ui-keyring authors & contributors
  const subject = new BehaviorSubject(false);
  const env = {
    isDevelopment: () => subject.getValue(),
    set: isDevelopment => {
      subject.next(isDevelopment);
    },
    subject
  };

  // Copyright 2017-2021 @polkadot/ui-keyring authors & contributors
  const ACCOUNT_PREFIX = 'account:';
  const ADDRESS_PREFIX = 'address:';
  const CONTRACT_PREFIX = 'contract:';

  function toHex(address) {
    return util$7.u8aToHex( // When saving pre-checksum changes, ensure that we can decode
    keyring$1.decodeAddress(address, true));
  }

  const accountKey = address => `${ACCOUNT_PREFIX}${toHex(address)}`;

  const addressKey = address => `${ADDRESS_PREFIX}${toHex(address)}`;

  const contractKey = address => `${CONTRACT_PREFIX}${toHex(address)}`;

  const accountRegex = new RegExp(`^${ACCOUNT_PREFIX}0x[0-9a-f]*`, '');
  const addressRegex = new RegExp(`^${ADDRESS_PREFIX}0x[0-9a-f]*`, '');
  const contractRegex = new RegExp(`^${CONTRACT_PREFIX}0x[0-9a-f]*`, '');

  // Copyright 2017-2021 @polkadot/ui-keyring authors & contributors
  function createOptionItem(address, _name) {
    const name = util$7.isUndefined(_name) ? address.length > 15 ? `${address.slice(0, 6)}…${address.slice(-6)}` : address : _name;
    return {
      key: address,
      name,
      value: address
    };
  }

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function callNext(current, subject, withTest) {
    const isDevMode = env.isDevelopment();
    const filtered = {};
    Object.keys(current).forEach(key => {
      const {
        json: {
          meta: {
            isTesting = false
          } = {}
        } = {}
      } = current[key];

      if (!withTest || isDevMode || isTesting !== true) {
        filtered[key] = current[key];
      }
    });
    subject.next(filtered);
  }

  function genericSubject(keyCreator, withTest = false) {
    let current = {};
    const subject = new BehaviorSubject({});

    const next = () => callNext(current, subject, withTest);

    env.subject.subscribe(next);
    return {
      add: (store, address, json, type) => {
        current = _objectSpread$1({}, current);
        current[address] = {
          json: _objectSpread$1(_objectSpread$1({}, json), {}, {
            address
          }),
          option: createOptionItem(address, json.meta.name),
          type
        }; // we do not store dev or injected accounts (external/transient)

        if (!json.meta.isInjected && (!json.meta.isTesting || env.isDevelopment())) {
          store.set(keyCreator(address), json);
        }

        next();
        return current[address];
      },
      remove: (store, address) => {
        current = _objectSpread$1({}, current);
        delete current[address];
        store.remove(keyCreator(address));
        next();
      },
      subject
    };
  }

  // Copyright 2017-2021 @polkadot/ui-keyring authors & contributors
  const accounts = genericSubject(accountKey, true);

  // Copyright 2017-2021 @polkadot/ui-keyring authors & contributors
  const addresses = genericSubject(addressKey);

  // Copyright 2017-2021 @polkadot/ui-keyring authors & contributors
  const contracts = genericSubject(contractKey);

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var assign = make_assign();
  var create$1 = make_create();
  var trim$1 = make_trim();
  var Global$5 = (typeof window !== 'undefined' ? window : commonjsGlobal);

  var util$6 = {
  	assign: assign,
  	create: create$1,
  	trim: trim$1,
  	bind: bind$1,
  	slice: slice$1,
  	each: each$7,
  	map: map,
  	pluck: pluck$1,
  	isList: isList$1,
  	isFunction: isFunction$1,
  	isObject: isObject$1,
  	Global: Global$5
  };

  function make_assign() {
  	if (Object.assign) {
  		return Object.assign
  	} else {
  		return function shimAssign(obj, props1, props2, etc) {
  			for (var i = 1; i < arguments.length; i++) {
  				each$7(Object(arguments[i]), function(val, key) {
  					obj[key] = val;
  				});
  			}			
  			return obj
  		}
  	}
  }

  function make_create() {
  	if (Object.create) {
  		return function create(obj, assignProps1, assignProps2, etc) {
  			var assignArgsList = slice$1(arguments, 1);
  			return assign.apply(this, [Object.create(obj)].concat(assignArgsList))
  		}
  	} else {
  		function F() {} // eslint-disable-line no-inner-declarations
  		return function create(obj, assignProps1, assignProps2, etc) {
  			var assignArgsList = slice$1(arguments, 1);
  			F.prototype = obj;
  			return assign.apply(this, [new F()].concat(assignArgsList))
  		}
  	}
  }

  function make_trim() {
  	if (String.prototype.trim) {
  		return function trim(str) {
  			return String.prototype.trim.call(str)
  		}
  	} else {
  		return function trim(str) {
  			return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
  		}
  	}
  }

  function bind$1(obj, fn) {
  	return function() {
  		return fn.apply(obj, Array.prototype.slice.call(arguments, 0))
  	}
  }

  function slice$1(arr, index) {
  	return Array.prototype.slice.call(arr, index || 0)
  }

  function each$7(obj, fn) {
  	pluck$1(obj, function(val, key) {
  		fn(val, key);
  		return false
  	});
  }

  function map(obj, fn) {
  	var res = (isList$1(obj) ? [] : {});
  	pluck$1(obj, function(v, k) {
  		res[k] = fn(v, k);
  		return false
  	});
  	return res
  }

  function pluck$1(obj, fn) {
  	if (isList$1(obj)) {
  		for (var i=0; i<obj.length; i++) {
  			if (fn(obj[i], i)) {
  				return obj[i]
  			}
  		}
  	} else {
  		for (var key in obj) {
  			if (obj.hasOwnProperty(key)) {
  				if (fn(obj[key], key)) {
  					return obj[key]
  				}
  			}
  		}
  	}
  }

  function isList$1(val) {
  	return (val != null && typeof val != 'function' && typeof val.length == 'number')
  }

  function isFunction$1(val) {
  	return val && {}.toString.call(val) === '[object Function]'
  }

  function isObject$1(val) {
  	return val && {}.toString.call(val) === '[object Object]'
  }

  var util$5 = util$6;
  var slice = util$5.slice;
  var pluck = util$5.pluck;
  var each$6 = util$5.each;
  var bind = util$5.bind;
  var create = util$5.create;
  var isList = util$5.isList;
  var isFunction = util$5.isFunction;
  var isObject = util$5.isObject;

  var storeEngine = {
  	createStore: createStore
  };

  var storeAPI = {
  	version: '2.0.12',
  	enabled: false,
  	
  	// get returns the value of the given key. If that value
  	// is undefined, it returns optionalDefaultValue instead.
  	get: function(key, optionalDefaultValue) {
  		var data = this.storage.read(this._namespacePrefix + key);
  		return this._deserialize(data, optionalDefaultValue)
  	},

  	// set will store the given value at key and returns value.
  	// Calling set with value === undefined is equivalent to calling remove.
  	set: function(key, value) {
  		if (value === undefined) {
  			return this.remove(key)
  		}
  		this.storage.write(this._namespacePrefix + key, this._serialize(value));
  		return value
  	},

  	// remove deletes the key and value stored at the given key.
  	remove: function(key) {
  		this.storage.remove(this._namespacePrefix + key);
  	},

  	// each will call the given callback once for each key-value pair
  	// in this store.
  	each: function(callback) {
  		var self = this;
  		this.storage.each(function(val, namespacedKey) {
  			callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''));
  		});
  	},

  	// clearAll will remove all the stored key-value pairs in this store.
  	clearAll: function() {
  		this.storage.clearAll();
  	},

  	// additional functionality that can't live in plugins
  	// ---------------------------------------------------

  	// hasNamespace returns true if this store instance has the given namespace.
  	hasNamespace: function(namespace) {
  		return (this._namespacePrefix == '__storejs_'+namespace+'_')
  	},

  	// createStore creates a store.js instance with the first
  	// functioning storage in the list of storage candidates,
  	// and applies the the given mixins to the instance.
  	createStore: function() {
  		return createStore.apply(this, arguments)
  	},
  	
  	addPlugin: function(plugin) {
  		this._addPlugin(plugin);
  	},
  	
  	namespace: function(namespace) {
  		return createStore(this.storage, this.plugins, namespace)
  	}
  };

  function _warn() {
  	var _console = (typeof console == 'undefined' ? null : console);
  	if (!_console) { return }
  	var fn = (_console.warn ? _console.warn : _console.log);
  	fn.apply(_console, arguments);
  }

  function createStore(storages, plugins, namespace) {
  	if (!namespace) {
  		namespace = '';
  	}
  	if (storages && !isList(storages)) {
  		storages = [storages];
  	}
  	if (plugins && !isList(plugins)) {
  		plugins = [plugins];
  	}

  	var namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '');
  	var namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null);
  	var legalNamespaces = /^[a-zA-Z0-9_\-]*$/; // alpha-numeric + underscore and dash
  	if (!legalNamespaces.test(namespace)) {
  		throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes')
  	}
  	
  	var _privateStoreProps = {
  		_namespacePrefix: namespacePrefix,
  		_namespaceRegexp: namespaceRegexp,

  		_testStorage: function(storage) {
  			try {
  				var testStr = '__storejs__test__';
  				storage.write(testStr, testStr);
  				var ok = (storage.read(testStr) === testStr);
  				storage.remove(testStr);
  				return ok
  			} catch(e) {
  				return false
  			}
  		},

  		_assignPluginFnProp: function(pluginFnProp, propName) {
  			var oldFn = this[propName];
  			this[propName] = function pluginFn() {
  				var args = slice(arguments, 0);
  				var self = this;

  				// super_fn calls the old function which was overwritten by
  				// this mixin.
  				function super_fn() {
  					if (!oldFn) { return }
  					each$6(arguments, function(arg, i) {
  						args[i] = arg;
  					});
  					return oldFn.apply(self, args)
  				}

  				// Give mixing function access to super_fn by prefixing all mixin function
  				// arguments with super_fn.
  				var newFnArgs = [super_fn].concat(args);

  				return pluginFnProp.apply(self, newFnArgs)
  			};
  		},

  		_serialize: function(obj) {
  			return JSON.stringify(obj)
  		},

  		_deserialize: function(strVal, defaultVal) {
  			if (!strVal) { return defaultVal }
  			// It is possible that a raw string value has been previously stored
  			// in a storage without using store.js, meaning it will be a raw
  			// string value instead of a JSON serialized string. By defaulting
  			// to the raw string value in case of a JSON parse error, we allow
  			// for past stored values to be forwards-compatible with store.js
  			var val = '';
  			try { val = JSON.parse(strVal); }
  			catch(e) { val = strVal; }

  			return (val !== undefined ? val : defaultVal)
  		},
  		
  		_addStorage: function(storage) {
  			if (this.enabled) { return }
  			if (this._testStorage(storage)) {
  				this.storage = storage;
  				this.enabled = true;
  			}
  		},

  		_addPlugin: function(plugin) {
  			var self = this;

  			// If the plugin is an array, then add all plugins in the array.
  			// This allows for a plugin to depend on other plugins.
  			if (isList(plugin)) {
  				each$6(plugin, function(plugin) {
  					self._addPlugin(plugin);
  				});
  				return
  			}

  			// Keep track of all plugins we've seen so far, so that we
  			// don't add any of them twice.
  			var seenPlugin = pluck(this.plugins, function(seenPlugin) {
  				return (plugin === seenPlugin)
  			});
  			if (seenPlugin) {
  				return
  			}
  			this.plugins.push(plugin);

  			// Check that the plugin is properly formed
  			if (!isFunction(plugin)) {
  				throw new Error('Plugins must be function values that return objects')
  			}

  			var pluginProperties = plugin.call(this);
  			if (!isObject(pluginProperties)) {
  				throw new Error('Plugins must return an object of function properties')
  			}

  			// Add the plugin function properties to this store instance.
  			each$6(pluginProperties, function(pluginFnProp, propName) {
  				if (!isFunction(pluginFnProp)) {
  					throw new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')
  				}
  				self._assignPluginFnProp(pluginFnProp, propName);
  			});
  		},
  		
  		// Put deprecated properties in the private API, so as to not expose it to accidential
  		// discovery through inspection of the store object.
  		
  		// Deprecated: addStorage
  		addStorage: function(storage) {
  			_warn('store.addStorage(storage) is deprecated. Use createStore([storages])');
  			this._addStorage(storage);
  		}
  	};

  	var store = create(_privateStoreProps, storeAPI, {
  		plugins: []
  	});
  	store.raw = {};
  	each$6(store, function(prop, propName) {
  		if (isFunction(prop)) {
  			store.raw[propName] = bind(store, prop);			
  		}
  	});
  	each$6(storages, function(storage) {
  		store._addStorage(storage);
  	});
  	each$6(plugins, function(plugin) {
  		store._addPlugin(plugin);
  	});
  	return store
  }

  var util$4 = util$6;
  var Global$4 = util$4.Global;

  var localStorage_1 = {
  	name: 'localStorage',
  	read: read$5,
  	write: write$5,
  	each: each$5,
  	remove: remove$5,
  	clearAll: clearAll$5,
  };

  function localStorage() {
  	return Global$4.localStorage
  }

  function read$5(key) {
  	return localStorage().getItem(key)
  }

  function write$5(key, data) {
  	return localStorage().setItem(key, data)
  }

  function each$5(fn) {
  	for (var i = localStorage().length - 1; i >= 0; i--) {
  		var key = localStorage().key(i);
  		fn(read$5(key), key);
  	}
  }

  function remove$5(key) {
  	return localStorage().removeItem(key)
  }

  function clearAll$5() {
  	return localStorage().clear()
  }

  // oldFF-globalStorage provides storage for Firefox
  // versions 6 and 7, where no localStorage, etc
  // is available.

  var util$3 = util$6;
  var Global$3 = util$3.Global;

  var oldFFGlobalStorage = {
  	name: 'oldFF-globalStorage',
  	read: read$4,
  	write: write$4,
  	each: each$4,
  	remove: remove$4,
  	clearAll: clearAll$4,
  };

  var globalStorage = Global$3.globalStorage;

  function read$4(key) {
  	return globalStorage[key]
  }

  function write$4(key, data) {
  	globalStorage[key] = data;
  }

  function each$4(fn) {
  	for (var i = globalStorage.length - 1; i >= 0; i--) {
  		var key = globalStorage.key(i);
  		fn(globalStorage[key], key);
  	}
  }

  function remove$4(key) {
  	return globalStorage.removeItem(key)
  }

  function clearAll$4() {
  	each$4(function(key, _) {
  		delete globalStorage[key];
  	});
  }

  // oldIE-userDataStorage provides storage for Internet Explorer
  // versions 6 and 7, where no localStorage, sessionStorage, etc
  // is available.

  var util$2 = util$6;
  var Global$2 = util$2.Global;

  var oldIEUserDataStorage = {
  	name: 'oldIE-userDataStorage',
  	write: write$3,
  	read: read$3,
  	each: each$3,
  	remove: remove$3,
  	clearAll: clearAll$3,
  };

  var storageName = 'storejs';
  var doc$1 = Global$2.document;
  var _withStorageEl = _makeIEStorageElFunction();
  var disable = (Global$2.navigator ? Global$2.navigator.userAgent : '').match(/ (MSIE 8|MSIE 9|MSIE 10)\./); // MSIE 9.x, MSIE 10.x

  function write$3(unfixedKey, data) {
  	if (disable) { return }
  	var fixedKey = fixKey(unfixedKey);
  	_withStorageEl(function(storageEl) {
  		storageEl.setAttribute(fixedKey, data);
  		storageEl.save(storageName);
  	});
  }

  function read$3(unfixedKey) {
  	if (disable) { return }
  	var fixedKey = fixKey(unfixedKey);
  	var res = null;
  	_withStorageEl(function(storageEl) {
  		res = storageEl.getAttribute(fixedKey);
  	});
  	return res
  }

  function each$3(callback) {
  	_withStorageEl(function(storageEl) {
  		var attributes = storageEl.XMLDocument.documentElement.attributes;
  		for (var i=attributes.length-1; i>=0; i--) {
  			var attr = attributes[i];
  			callback(storageEl.getAttribute(attr.name), attr.name);
  		}
  	});
  }

  function remove$3(unfixedKey) {
  	var fixedKey = fixKey(unfixedKey);
  	_withStorageEl(function(storageEl) {
  		storageEl.removeAttribute(fixedKey);
  		storageEl.save(storageName);
  	});
  }

  function clearAll$3() {
  	_withStorageEl(function(storageEl) {
  		var attributes = storageEl.XMLDocument.documentElement.attributes;
  		storageEl.load(storageName);
  		for (var i=attributes.length-1; i>=0; i--) {
  			storageEl.removeAttribute(attributes[i].name);
  		}
  		storageEl.save(storageName);
  	});
  }

  // Helpers
  //////////

  // In IE7, keys cannot start with a digit or contain certain chars.
  // See https://github.com/marcuswestin/store.js/issues/40
  // See https://github.com/marcuswestin/store.js/issues/83
  var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g");
  function fixKey(key) {
  	return key.replace(/^\d/, '___$&').replace(forbiddenCharsRegex, '___')
  }

  function _makeIEStorageElFunction() {
  	if (!doc$1 || !doc$1.documentElement || !doc$1.documentElement.addBehavior) {
  		return null
  	}
  	var scriptTag = 'script',
  		storageOwner,
  		storageContainer,
  		storageEl;

  	// Since #userData storage applies only to specific paths, we need to
  	// somehow link our data to a specific path.  We choose /favicon.ico
  	// as a pretty safe option, since all browsers already make a request to
  	// this URL anyway and being a 404 will not hurt us here.  We wrap an
  	// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
  	// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
  	// since the iframe access rules appear to allow direct access and
  	// manipulation of the document element, even for a 404 page.  This
  	// document can be used instead of the current document (which would
  	// have been limited to the current path) to perform #userData storage.
  	try {
  		/* global ActiveXObject */
  		storageContainer = new ActiveXObject('htmlfile');
  		storageContainer.open();
  		storageContainer.write('<'+scriptTag+'>document.w=window</'+scriptTag+'><iframe src="/favicon.ico"></iframe>');
  		storageContainer.close();
  		storageOwner = storageContainer.w.frames[0].document;
  		storageEl = storageOwner.createElement('div');
  	} catch(e) {
  		// somehow ActiveXObject instantiation failed (perhaps some special
  		// security settings or otherwse), fall back to per-path storage
  		storageEl = doc$1.createElement('div');
  		storageOwner = doc$1.body;
  	}

  	return function(storeFunction) {
  		var args = [].slice.call(arguments, 0);
  		args.unshift(storageEl);
  		// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
  		// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
  		storageOwner.appendChild(storageEl);
  		storageEl.addBehavior('#default#userData');
  		storageEl.load(storageName);
  		storeFunction.apply(this, args);
  		storageOwner.removeChild(storageEl);
  		return
  	}
  }

  // cookieStorage is useful Safari private browser mode, where localStorage
  // doesn't work but cookies do. This implementation is adopted from
  // https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage

  var util$1 = util$6;
  var Global$1 = util$1.Global;
  var trim = util$1.trim;

  var cookieStorage = {
  	name: 'cookieStorage',
  	read: read$2,
  	write: write$2,
  	each: each$2,
  	remove: remove$2,
  	clearAll: clearAll$2,
  };

  var doc = Global$1.document;

  function read$2(key) {
  	if (!key || !_has(key)) { return null }
  	var regexpStr = "(?:^|.*;\\s*)" +
  		escape(key).replace(/[\-\.\+\*]/g, "\\$&") +
  		"\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*";
  	return unescape(doc.cookie.replace(new RegExp(regexpStr), "$1"))
  }

  function each$2(callback) {
  	var cookies = doc.cookie.split(/; ?/g);
  	for (var i = cookies.length - 1; i >= 0; i--) {
  		if (!trim(cookies[i])) {
  			continue
  		}
  		var kvp = cookies[i].split('=');
  		var key = unescape(kvp[0]);
  		var val = unescape(kvp[1]);
  		callback(val, key);
  	}
  }

  function write$2(key, data) {
  	if(!key) { return }
  	doc.cookie = escape(key) + "=" + escape(data) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/";
  }

  function remove$2(key) {
  	if (!key || !_has(key)) {
  		return
  	}
  	doc.cookie = escape(key) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
  }

  function clearAll$2() {
  	each$2(function(_, key) {
  		remove$2(key);
  	});
  }

  function _has(key) {
  	return (new RegExp("(?:^|;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(doc.cookie)
  }

  var util = util$6;
  var Global = util.Global;

  var sessionStorage_1 = {
  	name: 'sessionStorage',
  	read: read$1,
  	write: write$1,
  	each: each$1,
  	remove: remove$1,
  	clearAll: clearAll$1
  };

  function sessionStorage() {
  	return Global.sessionStorage
  }

  function read$1(key) {
  	return sessionStorage().getItem(key)
  }

  function write$1(key, data) {
  	return sessionStorage().setItem(key, data)
  }

  function each$1(fn) {
  	for (var i = sessionStorage().length - 1; i >= 0; i--) {
  		var key = sessionStorage().key(i);
  		fn(read$1(key), key);
  	}
  }

  function remove$1(key) {
  	return sessionStorage().removeItem(key)
  }

  function clearAll$1() {
  	return sessionStorage().clear()
  }

  // memoryStorage is a useful last fallback to ensure that the store
  // is functions (meaning store.get(), store.set(), etc will all function).
  // However, stored values will not persist when the browser navigates to
  // a new page or reloads the current page.

  var memoryStorage_1 = {
  	name: 'memoryStorage',
  	read: read,
  	write: write,
  	each: each,
  	remove: remove,
  	clearAll: clearAll,
  };

  var memoryStorage = {};

  function read(key) {
  	return memoryStorage[key]
  }

  function write(key, data) {
  	memoryStorage[key] = data;
  }

  function each(callback) {
  	for (var key in memoryStorage) {
  		if (memoryStorage.hasOwnProperty(key)) {
  			callback(memoryStorage[key], key);
  		}
  	}
  }

  function remove(key) {
  	delete memoryStorage[key];
  }

  function clearAll(key) {
  	memoryStorage = {};
  }

  var all = [
  	// Listed in order of usage preference
  	localStorage_1,
  	oldFFGlobalStorage,
  	oldIEUserDataStorage,
  	cookieStorage,
  	sessionStorage_1,
  	memoryStorage_1
  ];

  /* eslint-disable */

  //  json2.js
  //  2016-10-28
  //  Public Domain.
  //  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
  //  See http://www.JSON.org/js.html
  //  This code should be minified before deployment.
  //  See http://javascript.crockford.com/jsmin.html

  //  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
  //  NOT CONTROL.

  //  This file creates a global JSON object containing two methods: stringify
  //  and parse. This file provides the ES5 JSON capability to ES3 systems.
  //  If a project might run on IE8 or earlier, then this file should be included.
  //  This file does nothing on ES5 systems.

  //      JSON.stringify(value, replacer, space)
  //          value       any JavaScript value, usually an object or array.
  //          replacer    an optional parameter that determines how object
  //                      values are stringified for objects. It can be a
  //                      function or an array of strings.
  //          space       an optional parameter that specifies the indentation
  //                      of nested structures. If it is omitted, the text will
  //                      be packed without extra whitespace. If it is a number,
  //                      it will specify the number of spaces to indent at each
  //                      level. If it is a string (such as "\t" or "&nbsp;"),
  //                      it contains the characters used to indent at each level.
  //          This method produces a JSON text from a JavaScript value.
  //          When an object value is found, if the object contains a toJSON
  //          method, its toJSON method will be called and the result will be
  //          stringified. A toJSON method does not serialize: it returns the
  //          value represented by the name/value pair that should be serialized,
  //          or undefined if nothing should be serialized. The toJSON method
  //          will be passed the key associated with the value, and this will be
  //          bound to the value.

  //          For example, this would serialize Dates as ISO strings.

  //              Date.prototype.toJSON = function (key) {
  //                  function f(n) {
  //                      // Format integers to have at least two digits.
  //                      return (n < 10)
  //                          ? "0" + n
  //                          : n;
  //                  }
  //                  return this.getUTCFullYear()   + "-" +
  //                       f(this.getUTCMonth() + 1) + "-" +
  //                       f(this.getUTCDate())      + "T" +
  //                       f(this.getUTCHours())     + ":" +
  //                       f(this.getUTCMinutes())   + ":" +
  //                       f(this.getUTCSeconds())   + "Z";
  //              };

  //          You can provide an optional replacer method. It will be passed the
  //          key and value of each member, with this bound to the containing
  //          object. The value that is returned from your method will be
  //          serialized. If your method returns undefined, then the member will
  //          be excluded from the serialization.

  //          If the replacer parameter is an array of strings, then it will be
  //          used to select the members to be serialized. It filters the results
  //          such that only members with keys listed in the replacer array are
  //          stringified.

  //          Values that do not have JSON representations, such as undefined or
  //          functions, will not be serialized. Such values in objects will be
  //          dropped; in arrays they will be replaced with null. You can use
  //          a replacer function to replace those with JSON values.

  //          JSON.stringify(undefined) returns undefined.

  //          The optional space parameter produces a stringification of the
  //          value that is filled with line breaks and indentation to make it
  //          easier to read.

  //          If the space parameter is a non-empty string, then that string will
  //          be used for indentation. If the space parameter is a number, then
  //          the indentation will be that many spaces.

  //          Example:

  //          text = JSON.stringify(["e", {pluribus: "unum"}]);
  //          // text is '["e",{"pluribus":"unum"}]'

  //          text = JSON.stringify(["e", {pluribus: "unum"}], null, "\t");
  //          // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

  //          text = JSON.stringify([new Date()], function (key, value) {
  //              return this[key] instanceof Date
  //                  ? "Date(" + this[key] + ")"
  //                  : value;
  //          });
  //          // text is '["Date(---current time---)"]'

  //      JSON.parse(text, reviver)
  //          This method parses a JSON text to produce an object or array.
  //          It can throw a SyntaxError exception.

  //          The optional reviver parameter is a function that can filter and
  //          transform the results. It receives each of the keys and values,
  //          and its return value is used instead of the original value.
  //          If it returns what it received, then the structure is not modified.
  //          If it returns undefined then the member is deleted.

  //          Example:

  //          // Parse the text. Values that look like ISO date strings will
  //          // be converted to Date objects.

  //          myData = JSON.parse(text, function (key, value) {
  //              var a;
  //              if (typeof value === "string") {
  //                  a =
  //   /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
  //                  if (a) {
  //                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
  //                          +a[5], +a[6]));
  //                  }
  //              }
  //              return value;
  //          });

  //          myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
  //              var d;
  //              if (typeof value === "string" &&
  //                      value.slice(0, 5) === "Date(" &&
  //                      value.slice(-1) === ")") {
  //                  d = new Date(value.slice(5, -1));
  //                  if (d) {
  //                      return d;
  //                  }
  //              }
  //              return value;
  //          });

  //  This is a reference implementation. You are free to copy, modify, or
  //  redistribute.

  /*jslint
      eval, for, this
  */

  /*property
      JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
      getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
      lastIndex, length, parse, prototype, push, replace, slice, stringify,
      test, toJSON, toString, valueOf
  */


  // Create a JSON object only if one does not already exist. We create the
  // methods in a closure to avoid creating global variables.

  if (typeof JSON !== "object") {
      JSON = {};
  }

  (function () {

      var rx_one = /^[\],:{}\s]*$/;
      var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
      var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
      var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
      var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

      function f(n) {
          // Format integers to have at least two digits.
          return n < 10
              ? "0" + n
              : n;
      }

      function this_value() {
          return this.valueOf();
      }

      if (typeof Date.prototype.toJSON !== "function") {

          Date.prototype.toJSON = function () {

              return isFinite(this.valueOf())
                  ? this.getUTCFullYear() + "-" +
                          f(this.getUTCMonth() + 1) + "-" +
                          f(this.getUTCDate()) + "T" +
                          f(this.getUTCHours()) + ":" +
                          f(this.getUTCMinutes()) + ":" +
                          f(this.getUTCSeconds()) + "Z"
                  : null;
          };

          Boolean.prototype.toJSON = this_value;
          Number.prototype.toJSON = this_value;
          String.prototype.toJSON = this_value;
      }

      var gap;
      var indent;
      var meta;
      var rep;


      function quote(string) {

  // If the string contains no control characters, no quote characters, and no
  // backslash characters, then we can safely slap some quotes around it.
  // Otherwise we must also replace the offending characters with safe escape
  // sequences.

          rx_escapable.lastIndex = 0;
          return rx_escapable.test(string)
              ? "\"" + string.replace(rx_escapable, function (a) {
                  var c = meta[a];
                  return typeof c === "string"
                      ? c
                      : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
              }) + "\""
              : "\"" + string + "\"";
      }


      function str(key, holder) {

  // Produce a string from holder[key].

          var i;          // The loop counter.
          var k;          // The member key.
          var v;          // The member value.
          var length;
          var mind = gap;
          var partial;
          var value = holder[key];

  // If the value has a toJSON method, call it to obtain a replacement value.

          if (value && typeof value === "object" &&
                  typeof value.toJSON === "function") {
              value = value.toJSON(key);
          }

  // If we were called with a replacer function, then call the replacer to
  // obtain a replacement value.

          if (typeof rep === "function") {
              value = rep.call(holder, key, value);
          }

  // What happens next depends on the value's type.

          switch (typeof value) {
          case "string":
              return quote(value);

          case "number":

  // JSON numbers must be finite. Encode non-finite numbers as null.

              return isFinite(value)
                  ? String(value)
                  : "null";

          case "boolean":
          case "null":

  // If the value is a boolean or null, convert it to a string. Note:
  // typeof null does not produce "null". The case is included here in
  // the remote chance that this gets fixed someday.

              return String(value);

  // If the type is "object", we might be dealing with an object or an array or
  // null.

          case "object":

  // Due to a specification blunder in ECMAScript, typeof null is "object",
  // so watch out for that case.

              if (!value) {
                  return "null";
              }

  // Make an array to hold the partial results of stringifying this object value.

              gap += indent;
              partial = [];

  // Is the value an array?

              if (Object.prototype.toString.apply(value) === "[object Array]") {

  // The value is an array. Stringify every element. Use null as a placeholder
  // for non-JSON values.

                  length = value.length;
                  for (i = 0; i < length; i += 1) {
                      partial[i] = str(i, value) || "null";
                  }

  // Join all of the elements together, separated with commas, and wrap them in
  // brackets.

                  v = partial.length === 0
                      ? "[]"
                      : gap
                          ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
                          : "[" + partial.join(",") + "]";
                  gap = mind;
                  return v;
              }

  // If the replacer is an array, use it to select the members to be stringified.

              if (rep && typeof rep === "object") {
                  length = rep.length;
                  for (i = 0; i < length; i += 1) {
                      if (typeof rep[i] === "string") {
                          k = rep[i];
                          v = str(k, value);
                          if (v) {
                              partial.push(quote(k) + (
                                  gap
                                      ? ": "
                                      : ":"
                              ) + v);
                          }
                      }
                  }
              } else {

  // Otherwise, iterate through all of the keys in the object.

                  for (k in value) {
                      if (Object.prototype.hasOwnProperty.call(value, k)) {
                          v = str(k, value);
                          if (v) {
                              partial.push(quote(k) + (
                                  gap
                                      ? ": "
                                      : ":"
                              ) + v);
                          }
                      }
                  }
              }

  // Join all of the member texts together, separated with commas,
  // and wrap them in braces.

              v = partial.length === 0
                  ? "{}"
                  : gap
                      ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
                      : "{" + partial.join(",") + "}";
              gap = mind;
              return v;
          }
      }

  // If the JSON object does not yet have a stringify method, give it one.

      if (typeof JSON.stringify !== "function") {
          meta = {    // table of character substitutions
              "\b": "\\b",
              "\t": "\\t",
              "\n": "\\n",
              "\f": "\\f",
              "\r": "\\r",
              "\"": "\\\"",
              "\\": "\\\\"
          };
          JSON.stringify = function (value, replacer, space) {

  // The stringify method takes a value and an optional replacer, and an optional
  // space parameter, and returns a JSON text. The replacer can be a function
  // that can replace values, or an array of strings that will select the keys.
  // A default replacer method can be provided. Use of the space parameter can
  // produce text that is more easily readable.

              var i;
              gap = "";
              indent = "";

  // If the space parameter is a number, make an indent string containing that
  // many spaces.

              if (typeof space === "number") {
                  for (i = 0; i < space; i += 1) {
                      indent += " ";
                  }

  // If the space parameter is a string, it will be used as the indent string.

              } else if (typeof space === "string") {
                  indent = space;
              }

  // If there is a replacer, it must be a function or an array.
  // Otherwise, throw an error.

              rep = replacer;
              if (replacer && typeof replacer !== "function" &&
                      (typeof replacer !== "object" ||
                      typeof replacer.length !== "number")) {
                  throw new Error("JSON.stringify");
              }

  // Make a fake root object containing our value under the key of "".
  // Return the result of stringifying the value.

              return str("", {"": value});
          };
      }


  // If the JSON object does not yet have a parse method, give it one.

      if (typeof JSON.parse !== "function") {
          JSON.parse = function (text, reviver) {

  // The parse method takes a text and an optional reviver function, and returns
  // a JavaScript value if the text is a valid JSON text.

              var j;

              function walk(holder, key) {

  // The walk method is used to recursively walk the resulting structure so
  // that modifications can be made.

                  var k;
                  var v;
                  var value = holder[key];
                  if (value && typeof value === "object") {
                      for (k in value) {
                          if (Object.prototype.hasOwnProperty.call(value, k)) {
                              v = walk(value, k);
                              if (v !== undefined) {
                                  value[k] = v;
                              } else {
                                  delete value[k];
                              }
                          }
                      }
                  }
                  return reviver.call(holder, key, value);
              }


  // Parsing happens in four stages. In the first stage, we replace certain
  // Unicode characters with escape sequences. JavaScript handles many characters
  // incorrectly, either silently deleting them, or treating them as line endings.

              text = String(text);
              rx_dangerous.lastIndex = 0;
              if (rx_dangerous.test(text)) {
                  text = text.replace(rx_dangerous, function (a) {
                      return "\\u" +
                              ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                  });
              }

  // In the second stage, we run the text against regular expressions that look
  // for non-JSON patterns. We are especially concerned with "()" and "new"
  // because they can cause invocation, and "=" because it can cause mutation.
  // But just to be safe, we want to reject all unexpected forms.

  // We split the second stage into 4 regexp operations in order to work around
  // crippling inefficiencies in IE's and Safari's regexp engines. First we
  // replace the JSON backslash pairs with "@" (a non-JSON character). Second, we
  // replace all simple value tokens with "]" characters. Third, we delete all
  // open brackets that follow a colon or comma or that begin the text. Finally,
  // we look to see that the remaining characters are only whitespace or "]" or
  // "," or ":" or "{" or "}". If that is so, then the text is safe for eval.

              if (
                  rx_one.test(
                      text
                          .replace(rx_two, "@")
                          .replace(rx_three, "]")
                          .replace(rx_four, "")
                  )
              ) {

  // In the third stage we use the eval function to compile the text into a
  // JavaScript structure. The "{" operator is subject to a syntactic ambiguity
  // in JavaScript: it can begin a block or an object literal. We wrap the text
  // in parens to eliminate the ambiguity.

                  j = eval("(" + text + ")");

  // In the optional fourth stage, we recursively walk the new structure, passing
  // each name/value pair to a reviver function for possible transformation.

                  return (typeof reviver === "function")
                      ? walk({"": j}, "")
                      : j;
              }

  // If the text is not JSON parseable, then a SyntaxError is thrown.

              throw new SyntaxError("JSON.parse");
          };
      }
  }());

  var json2 = json2Plugin;

  function json2Plugin() {
  	
  	return {}
  }

  var engine = storeEngine;

  var storages = all;
  var plugins = [json2];

  var store_legacy = engine.createStore(storages, plugins);

  // Copyright 2017-2021 @polkadot/ui-keyring authors & contributors
  class BrowserStore {
    all(cb) {
      store_legacy.each((value, key) => {
        cb(key, value);
      });
    }

    get(key, cb) {
      cb(store_legacy.get(key));
    }

    remove(key, cb) {
      store_legacy.remove(key);
      cb && cb();
    }

    set(key, value, cb) {
      store_legacy.set(key, value);
      cb && cb();
    }

  }

  var _accounts = /*#__PURE__*/_classPrivateFieldKey("accounts");

  var _addresses = /*#__PURE__*/_classPrivateFieldKey("addresses");

  var _contracts = /*#__PURE__*/_classPrivateFieldKey("contracts");

  var _keyring = /*#__PURE__*/_classPrivateFieldKey("keyring");

  class Base {
    constructor() {
      Object.defineProperty(this, _accounts, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _addresses, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _contracts, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _keyring, {
        writable: true,
        value: void 0
      });
      this._store = void 0;
      this._genesisHash = void 0;

      this.decodeAddress = (key, ignoreChecksum, ss58Format) => {
        return this.keyring.decodeAddress(key, ignoreChecksum, ss58Format);
      };

      this.encodeAddress = (key, ss58Format) => {
        return this.keyring.encodeAddress(key, ss58Format);
      };

      _classPrivateFieldBase(this, _accounts)[_accounts] = accounts;
      _classPrivateFieldBase(this, _addresses)[_addresses] = addresses;
      _classPrivateFieldBase(this, _contracts)[_contracts] = contracts;
      this._store = new BrowserStore();
    }

    get accounts() {
      return _classPrivateFieldBase(this, _accounts)[_accounts];
    }

    get addresses() {
      return _classPrivateFieldBase(this, _addresses)[_addresses];
    }

    get contracts() {
      return _classPrivateFieldBase(this, _contracts)[_contracts];
    }

    get keyring() {
      if (_classPrivateFieldBase(this, _keyring)[_keyring]) {
        return _classPrivateFieldBase(this, _keyring)[_keyring];
      }

      throw new Error('Keyring should be initialised via \'loadAll\' before use');
    }

    get genesisHash() {
      return this._genesisHash;
    }

    getPair(address) {
      return this.keyring.getPair(address);
    }

    getPairs() {
      return this.keyring.getPairs().filter(pair => env.isDevelopment() || pair.meta.isTesting !== true);
    }

    isAvailable(_address) {
      const accountsValue = this.accounts.subject.getValue();
      const addressesValue = this.addresses.subject.getValue();
      const contractsValue = this.contracts.subject.getValue();
      const address = util$7.isString(_address) ? _address : this.encodeAddress(_address);
      return !accountsValue[address] && !addressesValue[address] && !contractsValue[address];
    }

    isPassValid(password) {
      return password.length > 0;
    }

    setSS58Format(ss58Format) {
      if (_classPrivateFieldBase(this, _keyring)[_keyring] && util$7.isNumber(ss58Format)) {
        _classPrivateFieldBase(this, _keyring)[_keyring].setSS58Format(ss58Format);
      }
    }

    setDevMode(isDevelopment) {
      env.set(isDevelopment);
    }

    initKeyring(options) {
      const keyring = keyring$1.createTestKeyring(options, true);

      if (util$7.isBoolean(options.isDevelopment)) {
        this.setDevMode(options.isDevelopment);
      }

      _classPrivateFieldBase(this, _keyring)[_keyring] = keyring;
      this._genesisHash = options.genesisHash && (util$7.isString(options.genesisHash) ? options.genesisHash.toString() : options.genesisHash.toHex());
      this._store = options.store || this._store;
      this.addAccountPairs();
    }

    addAccountPairs() {
      this.keyring.getPairs().forEach(({
        address,
        meta
      }) => {
        this.accounts.add(this._store, address, {
          address,
          meta
        });
      });
    }

    addTimestamp(pair) {
      if (!pair.meta.whenCreated) {
        pair.setMeta({
          whenCreated: Date.now()
        });
      }
    }

  }

  // Copyright 2017-2021 @polkadot/ui-keyring authors & contributors
  const obervableAll = combineLatest([accounts.subject, addresses.subject, contracts.subject]).pipe(map$1(([accounts, addresses, contracts]) => ({
    accounts,
    addresses,
    contracts
  })));

  // Copyright 2017-2021 @polkadot/ui-keyring authors & contributors
  let hasCalledInitOptions = false;

  const sortByName = (a, b) => {
    const valueA = a.option.name;
    const valueB = b.option.name;
    return valueA.localeCompare(valueB);
  };

  const sortByCreated = (a, b) => {
    const valueA = a.json.meta.whenCreated || 0;
    const valueB = b.json.meta.whenCreated || 0;

    if (valueA < valueB) {
      return 1;
    }

    if (valueA > valueB) {
      return -1;
    }

    return 0;
  };

  class KeyringOption {
    constructor() {
      this.optionsSubject = new BehaviorSubject(this.emptyOptions());
    }

    createOptionHeader(name) {
      return {
        key: `header-${name.toLowerCase()}`,
        name,
        value: null
      };
    }

    init(keyring) {
      util$7.assert(!hasCalledInitOptions, 'Unable to initialise options more than once');
      obervableAll.subscribe(() => {
        const opts = this.emptyOptions();
        this.addAccounts(keyring, opts);
        this.addAddresses(keyring, opts);
        this.addContracts(keyring, opts);
        opts.address = this.linkItems({
          Addresses: opts.address,
          Recent: opts.recent
        });
        opts.account = this.linkItems({
          Accounts: opts.account,
          Development: opts.testing
        });
        opts.contract = this.linkItems({
          Contracts: opts.contract
        });
        opts.all = [].concat(opts.account, opts.address);
        opts.allPlus = [].concat(opts.account, opts.address, opts.contract);
        this.optionsSubject.next(opts);
      });
      hasCalledInitOptions = true;
    }

    linkItems(items) {
      return Object.keys(items).reduce((result, header) => {
        const options = items[header];
        return result.concat(options.length ? [this.createOptionHeader(header)] : [], options);
      }, []);
    }

    addAccounts(keyring, options) {
      const available = keyring.accounts.subject.getValue();
      Object.values(available).sort(sortByName).forEach(({
        json: {
          meta: {
            isTesting = false
          }
        },
        option
      }) => {
        if (!isTesting) {
          options.account.push(option);
        } else {
          options.testing.push(option);
        }
      });
    }

    addAddresses(keyring, options) {
      const available = keyring.addresses.subject.getValue();
      Object.values(available).filter(({
        json
      }) => !!json.meta.isRecent).sort(sortByCreated).forEach(({
        option
      }) => {
        options.recent.push(option);
      });
      Object.values(available).filter(({
        json
      }) => !json.meta.isRecent).sort(sortByName).forEach(({
        option
      }) => {
        options.address.push(option);
      });
    }

    addContracts(keyring, options) {
      const available = keyring.contracts.subject.getValue();
      Object.values(available).sort(sortByName).forEach(({
        option
      }) => {
        options.contract.push(option);
      });
    }

    emptyOptions() {
      return {
        account: [],
        address: [],
        all: [],
        allPlus: [],
        contract: [],
        recent: [],
        testing: []
      };
    }

  }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  const RECENT_EXPIRY = 24 * 60 * 60; // No accounts (or test accounts) should be loaded until after the chain determination.
  // Chain determination occurs outside of Keyring. Loading `keyring.loadAll({ type: 'ed25519' | 'sr25519' })` is triggered
  // from the API after the chain is received

  var _stores = /*#__PURE__*/_classPrivateFieldKey("stores");

  class Keyring extends Base {
    constructor(...args) {
      super(...args);
      this.keyringOption = new KeyringOption();
      Object.defineProperty(this, _stores, {
        writable: true,
        value: {
          account: () => this.accounts,
          address: () => this.addresses,
          contract: () => this.contracts
        }
      });
    }

    addExternal(address, meta = {}) {
      const pair = this.keyring.addFromAddress(address, _objectSpread(_objectSpread({}, meta), {}, {
        isExternal: true
      }), null);
      return {
        json: this.saveAccount(pair),
        pair
      };
    }

    addHardware(address, hardwareType, meta = {}) {
      return this.addExternal(address, _objectSpread(_objectSpread({}, meta), {}, {
        hardwareType,
        isHardware: true
      }));
    }

    addMultisig(addresses, threshold, meta = {}) {
      const address = utilCrypto.createKeyMulti(addresses, threshold); // we could use `sortAddresses`, but rather use internal encode/decode so we are 100%

      const who = util$7.u8aSorted(addresses.map(who => this.decodeAddress(who))).map(who => this.encodeAddress(who));
      return this.addExternal(address, _objectSpread(_objectSpread({}, meta), {}, {
        isMultisig: true,
        threshold: util$7.bnToBn(threshold).toNumber(),
        who
      }));
    }

    addPair(pair, password) {
      this.keyring.addPair(pair);
      return {
        json: this.saveAccount(pair, password),
        pair
      };
    }

    addUri(suri, password, meta = {}, type) {
      const pair = this.keyring.addFromUri(suri, meta, type);
      return {
        json: this.saveAccount(pair, password),
        pair
      };
    }

    backupAccount(pair, password) {
      if (!pair.isLocked) {
        pair.lock();
      }

      pair.decodePkcs8(password);
      return pair.toJson(password);
    }

    async backupAccounts(addresses, password) {
      const accountPromises = addresses.map(address => {
        return new Promise(resolve => {
          this._store.get(accountKey(address), resolve);
        });
      });
      const accounts = await Promise.all(accountPromises);
      return _objectSpread(_objectSpread({}, utilCrypto.jsonEncrypt(util$7.stringToU8a(JSON.stringify(accounts)), ['batch-pkcs8'], password)), {}, {
        accounts: accounts.map(account => ({
          address: account.address,
          meta: account.meta
        }))
      });
    }

    createFromJson(json, meta = {}) {
      return this.keyring.createFromJson(_objectSpread(_objectSpread({}, json), {}, {
        meta: _objectSpread(_objectSpread({}, json.meta || {}), {}, {
          meta
        })
      }));
    }

    createFromUri(suri, meta = {}, type) {
      return this.keyring.createFromUri(suri, meta, type);
    }

    encryptAccount(pair, password) {
      const json = pair.toJson(password);
      json.meta.whenEdited = Date.now();
      this.keyring.addFromJson(json);
      this.accounts.add(this._store, pair.address, json, pair.type);
    }

    forgetAccount(address) {
      this.keyring.removePair(address);
      this.accounts.remove(this._store, address);
    }

    forgetAddress(address) {
      this.addresses.remove(this._store, address);
    }

    forgetContract(address) {
      this.contracts.remove(this._store, address);
    }

    getAccount(address) {
      return this.getAddress(address, 'account');
    }

    getAccounts() {
      const available = this.accounts.subject.getValue();
      return Object.keys(available).map(address => this.getAddress(address, 'account')).filter(account => env.isDevelopment() || account.meta.isTesting !== true);
    }

    getAddress(_address, type = null) {
      const address = util$7.isString(_address) ? _address : this.encodeAddress(_address);
      const publicKey = this.decodeAddress(address);
      const stores = type ? [_classPrivateFieldBase(this, _stores)[_stores][type]] : Object.values(_classPrivateFieldBase(this, _stores)[_stores]);
      const info = stores.reduce((lastInfo, store) => store().subject.getValue()[address] || lastInfo, undefined);
      return info && {
        address,
        meta: info.json.meta,
        publicKey
      };
    }

    getAddresses() {
      const available = this.addresses.subject.getValue();
      return Object.keys(available).map(address => this.getAddress(address));
    }

    getContract(address) {
      return this.getAddress(address, 'contract');
    }

    getContracts() {
      const available = this.contracts.subject.getValue();
      return Object.entries(available).filter(([, {
        json: {
          meta: {
            contract
          }
        }
      }]) => !!contract && contract.genesisHash === this.genesisHash).map(([address]) => this.getContract(address));
    }

    rewriteKey(json, key, hexAddr, creator) {
      if (hexAddr.substr(0, 2) === '0x') {
        return;
      }

      this._store.remove(key);

      this._store.set(creator(hexAddr), json);
    }

    loadAccount(json, key) {
      if (!json.meta.isTesting && json.encoded) {
        // FIXME Just for the transition period (ignoreChecksum)
        const pair = this.keyring.addFromJson(json, true);
        this.accounts.add(this._store, pair.address, json, pair.type);
      }

      const [, hexAddr] = key.split(':');
      this.rewriteKey(json, key, hexAddr.trim(), accountKey);
    }

    loadAddress(json, key) {
      const {
        isRecent,
        whenCreated = 0
      } = json.meta;

      if (isRecent && Date.now() - whenCreated > RECENT_EXPIRY) {
        this._store.remove(key);

        return;
      } // We assume anything hex that is not 32bytes (64 + 2 bytes hex) is an Ethereum-like address
      // (this caters for both H160 addresses as well as full or compressed publicKeys) - in the case
      // of both ecdsa and ethereum, we keep it as-is


      const address = util$7.isHex(json.address) && json.address.length !== 66 ? json.address : this.encodeAddress(util$7.isHex(json.address) ? util$7.hexToU8a(json.address) // FIXME Just for the transition period (ignoreChecksum)
      : this.decodeAddress(json.address, true));
      const [, hexAddr] = key.split(':');
      this.addresses.add(this._store, address, json);
      this.rewriteKey(json, key, hexAddr, addressKey);
    }

    loadContract(json, key) {
      const address = this.encodeAddress(this.decodeAddress(json.address));
      const [, hexAddr] = key.split(':'); // move genesisHash to top-level (TODO Remove from contracts section?)

      json.meta.genesisHash = json.meta.genesisHash || json.meta.contract && json.meta.contract.genesisHash;
      this.contracts.add(this._store, address, json);
      this.rewriteKey(json, key, hexAddr, contractKey);
    }

    loadInjected(address, meta, type) {
      const json = {
        address,
        meta: _objectSpread(_objectSpread({}, meta), {}, {
          isInjected: true
        })
      };
      const pair = this.keyring.addFromAddress(address, json.meta, null, type);
      this.accounts.add(this._store, pair.address, json, pair.type);
    }

    allowGenesis(json) {
      if (json && json.meta && this.genesisHash) {
        const hashes = Object.values(uiSettings.chains).find(hashes => hashes.includes(this.genesisHash || '')) || [this.genesisHash];

        if (json.meta.genesisHash) {
          return hashes.includes(json.meta.genesisHash);
        } else if (json.meta.contract) {
          return hashes.includes(json.meta.contract.genesisHash);
        }
      }

      return true;
    }

    loadAll(options, injected = []) {
      super.initKeyring(options);

      this._store.all((key, json) => {
        if (options.filter ? options.filter(json) : true) {
          try {
            if (this.allowGenesis(json)) {
              if (accountRegex.test(key)) {
                this.loadAccount(json, key);
              } else if (addressRegex.test(key)) {
                this.loadAddress(json, key);
              } else if (contractRegex.test(key)) {
                this.loadContract(json, key);
              }
            }
          } catch (error) {// ignore
          }
        }
      });

      injected.forEach(account => {
        if (this.allowGenesis(account)) {
          try {
            this.loadInjected(account.address, account.meta, account.type);
          } catch (error) {// ignore
          }
        }
      });
      this.keyringOption.init(this);
    }

    restoreAccount(json, password) {
      const cryptoType = Array.isArray(json.encoding.content) ? json.encoding.content[1] : 'ed25519';
      const encType = Array.isArray(json.encoding.type) ? json.encoding.type : [json.encoding.type];
      const pair = keyring$1.createPair({
        toSS58: this.encodeAddress,
        type: cryptoType
      }, {
        publicKey: this.decodeAddress(json.address, true)
      }, json.meta, util$7.isHex(json.encoded) ? util$7.hexToU8a(json.encoded) : utilCrypto.base64Decode(json.encoded), encType); // unlock, save account and then lock (locking cleans secretKey, so needs to be last)

      pair.decodePkcs8(password);
      this.addPair(pair, password);
      pair.lock();
      return pair;
    }

    restoreAccounts(json, password) {
      const accounts = JSON.parse(util$7.u8aToString(utilCrypto.jsonDecrypt(json, password)));
      accounts.forEach(account => {
        this.loadAccount(account, accountKey(account.address));
      });
    }

    saveAccount(pair, password) {
      this.addTimestamp(pair);
      const json = pair.toJson(password);
      this.keyring.addFromJson(json);
      this.accounts.add(this._store, pair.address, json, pair.type);
      return json;
    }

    saveAccountMeta(pair, meta) {
      const address = pair.address;

      this._store.get(accountKey(address), json => {
        pair.setMeta(meta);
        json.meta = pair.meta;
        this.accounts.add(this._store, address, json, pair.type);
      });
    }

    saveAddress(address, meta, type = 'address') {
      const available = this.addresses.subject.getValue();
      const json = available[address] && available[address].json || {
        address,
        meta: {
          isRecent: undefined,
          whenCreated: Date.now()
        }
      };
      Object.keys(meta).forEach(key => {
        json.meta[key] = meta[key];
      });
      delete json.meta.isRecent;

      _classPrivateFieldBase(this, _stores)[_stores][type]().add(this._store, address, json);

      return json;
    }

    saveContract(address, meta) {
      return this.saveAddress(address, meta, 'contract');
    }

    saveRecent(address) {
      const available = this.addresses.subject.getValue();

      if (!available[address]) {
        this.addresses.add(this._store, address, {
          address,
          meta: {
            genesisHash: this.genesisHash,
            isRecent: true,
            whenCreated: Date.now()
          }
        });
      }

      return this.addresses.subject.getValue()[address];
    }

  }

  // Copyright 2017-2021 @polkadot/ui-keyring authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  // Auto-generated by @polkadot/dev, do not edit
  const packageInfo = {
    name: '@polkadot/ui-keyring',
    version: '0.85.1'
  };

  // Copyright 2017-2021 @polkadot/ui-keyring authors & contributors
  const keyring = new Keyring();

  Object.defineProperty(exports, 'Ledger', {
    enumerable: true,
    get: function () {
      return hwLedger.Ledger;
    }
  });
  exports.Keyring = Keyring;
  exports.keyring = keyring;
  exports.packageInfo = packageInfo;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

}({}, polkadotKeyring, polkadotUiSettings, polkadotUtil, polkadotUtilCrypto, polkadotHwLedger));
